(* default interface file generated by ocaml.
  TODO : make some stuff abstract (private in java lingo) *)

(* Tips on how to split the library in different files :
  - If you want to do a file to host values pertaining to a certain type, for
    instance [program], name the file [program.ml] and type for programs [t].
    This way you get to type `Program.t` instead of `Program.program`.
  - This file describe the interface of the whole library. Therefore you need to
    specify that there are submodules if you want to expose them. To continue on
    our previous example, you need to add :
    [module Program : sig ... end]. In between the [...], put every value or
    type from [Program] that you want to expose. If you want to expose all of
    them, add the following instead :
    [module Program : module type of Program]. *)

type prob = float

type 'a dist = ('a * prob) list

val empty_dist : 'a list

val bernoulli : p:float -> (int * float) list

val sample : 'a -> 'a

val print_dist : ('a -> string) -> ('a * float) list -> unit

type 'a program =
  | Return : 'a -> 'a program
  | Assume : (bool * 'a program) -> 'a program
  | Factor : (prob * 'a program) -> 'a program
  | Sample : ('a dist * ('a -> 'b program)) -> 'b program

val factor_dist : float -> ('a * float) list -> ('a * float) list

val list_of_hashtbl : ('a, 'b) Hashtbl.t -> ('a * 'b) list

val combine_dist : ('a * float) list list -> ('a * float) list

val infer : 'a program -> ('a * float) list

val ( let* ) : 'a dist -> ('a -> 'b program) -> 'b program

val assume : bool -> 'a program -> 'a program

val factor : prob -> 'a program -> 'a program

val return : 'a -> 'a program
